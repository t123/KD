@using KD.Infrastructure.ViewModels.Objects
@implements IAsyncDisposable
@inherits FluxorComponent

@if (!EventsState.Value.IsLoading)
{
    if (EventsState.Value.TabMapping.ContainsKey(Tab))
    {
        var itemsView = EventsState.Value.TabMapping[Tab];
        <GenericViewHeader Label="Events" LastUpdate="@itemsView.LastUpdate">
        </GenericViewHeader>
        <MudDataGrid Items="@(itemsView.Items)" Filterable="true" SortMode="@SortMode.Single" Groupable="false" T="EventsViewModel" Dense="true">
            <Columns>
                <TemplateColumn Title="Name">
                    <CellTemplate>
                        <a onclick="@(() => NameClick(context.Item))">@context.Item.Name</a>
                    </CellTemplate>
                </TemplateColumn>
                <PropertyColumn Property="p => p.Namespace" />
                <PropertyColumn Property="p => p.Reason" />
                <PropertyColumn Property="p => p.Type" />
                <PropertyColumn Property="p => p.Source" />
                <TemplateColumn Title="Regarding">
                    <CellTemplate>
                        @(context.Item.Regarding.Kind + " / " + context.Item.Regarding.Name)
                    </CellTemplate>
                </TemplateColumn>
                <PropertyColumn Property="p => p.Count" />
                <PropertyColumn Property="p => p.LastSeen" />
            </Columns>
        </MudDataGrid>
    }
}
else
{
    <MudProgressCircular Indeterminate="true" />
}

@code {
    private bool IsDisposed;
    private CancellationTokenSource CancellationTokenSource { get; set; } = new();

    [Inject]
    public IState<EventsViewState> EventsState { get; set; }

    [Parameter]
    public required Tab Tab { get; set; }

    [Inject]
    public IDispatcher Dispatcher { get; set; }

    private void NameClick(EventsViewModel viewModel)
    {
        Dispatcher.Dispatch(new OpenPropertiesAction(viewModel, ObjectType.Event, Tab, CancellationTokenSource.Token));
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Dispatcher.Dispatch(new FetchKubernetesEventsAction(Tab, CancellationTokenSource.Token));
    }

    protected override ValueTask DisposeAsyncCore(bool disposing)
    {
        if (!IsDisposed)
        {
            IsDisposed = true;

            if (disposing)
            {
                CancellationTokenSource.Cancel();
            }
        }

        return base.DisposeAsyncCore(disposing);
    }
}